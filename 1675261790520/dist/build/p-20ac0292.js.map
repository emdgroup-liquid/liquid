{"version":3,"names":["focusableSelector","map","selector","join","getFirstFocusable","el","matches","tagName","hostEl","getRootNode","slotName","getAttribute","slottedEl","querySelector","Array","from","children","find","child","hasAttribute","shadowRoot","shadowRootChildren","focusable","isInnerFocusable","element","autofocusHandlerTimeout","registerAutofocus","autofocus","setTimeout","firstWithAutofocus","document","querySelectorAll","disabled","focusInner"],"sources":["./src/liquid/utils/focus.ts"],"sourcesContent":["const focusableSelector = [\n  'a[href]',\n  'area[href]',\n  'input:not([type=\"hidden\"]):not([type=\"radio\"]):not(:disabled)',\n  'input[type=\"radio\"]:not(:disabled)',\n  'select:not(:disabled)',\n  'textarea:not(:disabled)',\n  'button:not(:disabled)',\n  'iframe',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]',\n  '[tabindex]',\n]\n  .map((selector) => selector + ':not([tabindex^=\"-\"])')\n  .join(',')\n\nexport const getFirstFocusable = (el: HTMLElement): HTMLElement | undefined => {\n  // Directly focusable element.\n  if (el.matches(focusableSelector)) {\n    return el\n  }\n\n  // Slot.\n  if (el.tagName === 'SLOT') {\n    const hostEl = el.getRootNode()['host']\n    const slotName = el.getAttribute('name')\n    const slottedEl = slotName\n      ? hostEl.querySelector(`[slot=\"${el.getAttribute('name')}\"]`)\n      : Array.from(hostEl.children).find(\n          (child) => !(child as HTMLElement).hasAttribute('slot')\n        )\n    if (slottedEl) {\n      return getFirstFocusable(slottedEl)\n    }\n    return null\n  }\n\n  // Web Component.\n  if (el.shadowRoot) {\n    const shadowRootChildren = Array.from(el.shadowRoot.children)\n    for (const child of shadowRootChildren) {\n      const focusable = getFirstFocusable(child as HTMLElement)\n      if (focusable) return focusable\n    }\n  }\n\n  // Element with children.\n  const children = Array.from(el.children)\n  for (const child of children) {\n    const focusable = getFirstFocusable(child as HTMLElement)\n    if (focusable) return focusable\n  }\n\n  return null\n}\n\nexport const isInnerFocusable = <T extends object>(\n  element?: T\n): element is T & InnerFocusable => element && 'focusInner' in element\n\nlet autofocusHandlerTimeout\nexport const registerAutofocus = (autofocus: boolean) => {\n  if (!autofocus || autofocusHandlerTimeout) return\n  autofocusHandlerTimeout = setTimeout(() => {\n    const firstWithAutofocus = Array.from(\n      document.querySelectorAll<HTMLInputElement>('[autofocus]')\n    ).find((el) => !el.disabled)\n    if (isInnerFocusable(firstWithAutofocus)) {\n      firstWithAutofocus.focusInner()\n    }\n  }, 200)\n}\n"],"mappings":"AAAA,MAAMA,EAAoB,CACxB,UACA,aACA,gEACA,qCACA,wBACA,0BACA,wBACA,SACA,kBACA,kBACA,oBACA,cAECC,KAAKC,GAAaA,EAAW,0BAC7BC,KAAK,K,MAEKC,EAAqBC,IAEhC,GAAIA,EAAGC,QAAQN,GAAoB,CACjC,OAAOK,C,CAIT,GAAIA,EAAGE,UAAY,OAAQ,CACzB,MAAMC,EAASH,EAAGI,cAAc,QAChC,MAAMC,EAAWL,EAAGM,aAAa,QACjC,MAAMC,EAAYF,EACdF,EAAOK,cAAc,UAAUR,EAAGM,aAAa,aAC/CG,MAAMC,KAAKP,EAAOQ,UAAUC,MACzBC,IAAYA,EAAsBC,aAAa,UAEtD,GAAIP,EAAW,CACb,OAAOR,EAAkBQ,E,CAE3B,OAAO,I,CAIT,GAAIP,EAAGe,WAAY,CACjB,MAAMC,EAAqBP,MAAMC,KAAKV,EAAGe,WAAWJ,UACpD,IAAK,MAAME,KAASG,EAAoB,CACtC,MAAMC,EAAYlB,EAAkBc,GACpC,GAAII,EAAW,OAAOA,C,EAK1B,MAAMN,EAAWF,MAAMC,KAAKV,EAAGW,UAC/B,IAAK,MAAME,KAASF,EAAU,CAC5B,MAAMM,EAAYlB,EAAkBc,GACpC,GAAII,EAAW,OAAOA,C,CAGxB,OAAO,IAAI,E,MAGAC,EACXC,GACkCA,GAAW,eAAgBA,EAE/D,IAAIC,E,MACSC,EAAqBC,IAChC,IAAKA,GAAaF,EAAyB,OAC3CA,EAA0BG,YAAW,KACnC,MAAMC,EAAqBf,MAAMC,KAC/Be,SAASC,iBAAmC,gBAC5Cd,MAAMZ,IAAQA,EAAG2B,WACnB,GAAIT,EAAiBM,GAAqB,CACxCA,EAAmBI,Y,IAEpB,IAAI,S"}