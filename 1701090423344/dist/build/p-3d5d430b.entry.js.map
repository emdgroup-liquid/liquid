{"version":3,"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","window","slice","Array","matches","Element","msMatchesSelector","_focusableElementsString","join","InertRoot","rootElement","inertManager","this","_inertManager","_rootElement","_managedNodes","Set","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","value","destructor","disconnect","removeAttribute","forEach","inertNode","_unmanageNode","node","startNode","_this2","composedTreeWalk","_visitNode","activeElement","document","body","contains","root","undefined","nodeType","Node","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","ELEMENT_NODE","element","_adoptInertRoot","call","_manageNode","register","add","deregister","_unmanageSubtree","_this3","inertSubroot","getInertRoot","setInert","managedNodes","savedInertNode","records","self","record","type","addedNodes","removedNodes","attributeName","managedNode","get","set","ariaHidden","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","_throwIfDestroyed","destroyed","Error","tabIndex","hasSavedTabIndex","addInertRoot","removeInertRoot","size","InertManager","_document","Map","_watchForInert","addInertStyle","head","documentElement","readyState","addEventListener","_onDocumentLoaded","inert","has","parent","_inertRoot","inertElements","querySelectorAll","inertElement","_this","unshift","callback","shadowRootAncestor","shadowRoot","localName","content","distributedNodes","getDistributedNodes","slot","_distributedNodes","assignedNodes","flatten","_i","child","firstChild","nextSibling","querySelector","style","createElement","textContent","appendChild","HTMLElement","hasOwnProperty","isArray","getTag","INFINITY","baseToString","result","toString","isString","isNumber","isBoolean","isObjectLike","isObject","isDefined","isBlank","trim","EXTENDED_SEARCH_UNAVAILABLE","INCORRECT_INDEX_TYPE","LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY","PATTERN_LENGTH_TOO_LARGE","max","MISSING_KEY_PROPERTY","name","INVALID_KEY_WEIGHT_VALUE","hasOwn","KeyStore","constructor","keys","_keys","_keyMap","totalWeight","obj","createKey","weight","push","id","keyId","toJSON","JSON","stringify","path","src","getFn","createKeyPath","createKeyId","split","list","arr","deepGet","index","len","MatchOptions","includeMatches","findAllMatches","minMatchCharLength","BasicOptions","isCaseSensitive","includeScore","shouldSort","sortFn","a","b","score","idx","FuzzyOptions","location","threshold","distance","AdvancedOptions","useExtendedSearch","ignoreLocation","ignoreFieldNorm","fieldNormWeight","Config","SPACE","norm","mantissa","cache","m","Math","pow","numTokens","match","n","parseFloat","round","clear","FuseIndex","isCreated","setIndexRecords","setSources","docs","setKeys","_keysMap","create","doc","docIndex","_addString","_addObject","removeAt","splice","getValueForItemAtKeyId","item","v","$","keyIndex","subRecords","stack","nestedArrIndex","pop","subRecord","k","createIndex","myIndex","map","parseIndex","data","computeScore$1","pattern","errors","currentLocation","expectedLocation","accuracy","proximity","abs","convertMaskToIndices","matchmask","indices","start","end","MAX_BITS","search","text","patternAlphabet","patternLen","textLen","min","currentThreshold","bestLocation","computeMatches","matchMask","indexOf","lastBitArr","finalScore","binMax","mask","binMin","binMid","floor","finish","bitArr","j","charMatch","charAt","isMatch","createPatternAlphabet","char","BitapSearch","options","toLowerCase","chunks","addChunk","startIndex","alphabet","remainder","substr","searchIn","allIndices","totalScore","hasMatches","BaseMatch","isMultiMatch","getMatch","multiRegex","isSingleMatch","singleRegex","exp","ExactMatch","super","InverseExactMatch","PrefixExactMatch","startsWith","InversePrefixExactMatch","SuffixExactMatch","endsWith","InverseSuffixExactMatch","FuzzyMatch","_bitapSearch","IncludeMatch","searchers","searchersLen","SPACE_RE","OR_TOKEN","parseQuery","query","filter","results","queryItem","found","searcher","token","MultiMatchSet","ExtendedSearch","condition","_","numMatches","qLen","pLen","registeredSearchers","args","createSearcher","searcherClass","LogicalOperator","AND","OR","KeyType","PATH","PATTERN","isExpression","isPath","isLeaf","convertToExplicit","parse","auto","next","isQueryPath","children","operator","computeScore","Number","EPSILON","transformMatches","refIndex","transformScore","format","transformers","transformer","Fuse","_keyStore","setCollection","_docs","_myIndex","remove","predicate","getIndex","limit","_searchStringList","_searchObjectList","_searchLogical","sort","expression","evaluate","_findMatches","res","resultMap","expResults","version","config","docsSearchCss","DocsSearch","handleClick","ev","preventDefault","onSearchClose","handleEscapeDown","isActive","stopImmediatePropagation","handleKeyDown","closest","searchInput","_a","searchResults","_b","nextElementSibling","classList","focusedSearchResult","prevSibling","previousElementSibling","scrollTo","href","handleSubmit","handleChange","searchResult","fuse","componentWillLoad","componentDidLoad","eventBus","on","SearchEventType","open","onSearchOpen","getElementById","setTimeout","focusInner","emit","close","render","h","Host","class","role","autocomplete","onInput","placeholder","ref","el","spellcheck","fill","viewBox","cx","cy","stroke","rx","ry","d","breadcrumbs","url","title","crumb"],"sources":["../node_modules/.pnpm/wicg-inert@3.1.2/node_modules/wicg-inert/dist/inert.esm.js","../node_modules/.pnpm/fuse.js@6.6.2/node_modules/fuse.js/dist/fuse.esm.js","../src/docs/components/docs-search/docs-search.css?tag=docs-search","../src/docs/components/docs-search/docs-search.tsx"],"sourcesContent":["var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n(function () {\n  // Return early if we're not running inside of the browser.\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  // Convenience function for converting NodeLists.\n  /** @type {typeof Array.prototype.slice} */\n  var slice = Array.prototype.slice;\n\n  /**\n   * IE has a non-standard name for \"matches\".\n   * @type {typeof Element.prototype.matches}\n   */\n  var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n  /** @type {string} */\n  var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n  /**\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n   * attribute.\n   *\n   * Its main functions are:\n   *\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\n   *\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\n   *   `deregister` method on `InertManager` for each managed inert node.\n   */\n\n  var InertRoot = function () {\n    /**\n     * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.\n     * @param {!InertManager} inertManager The global singleton InertManager object.\n     */\n    function InertRoot(rootElement, inertManager) {\n      _classCallCheck(this, InertRoot);\n\n      /** @type {!InertManager} */\n      this._inertManager = inertManager;\n\n      /** @type {!HTMLElement} */\n      this._rootElement = rootElement;\n\n      /**\n       * @type {!Set<!InertNode>}\n       * All managed focusable nodes in this InertRoot's subtree.\n       */\n      this._managedNodes = new Set();\n\n      // Make the subtree hidden from assistive technology\n      if (this._rootElement.hasAttribute('aria-hidden')) {\n        /** @type {?string} */\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n      } else {\n        this._savedAriaHidden = null;\n      }\n      this._rootElement.setAttribute('aria-hidden', 'true');\n\n      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n      this._makeSubtreeUnfocusable(this._rootElement);\n\n      // Watch for:\n      // - any additions in the subtree: make them unfocusable too\n      // - any removals from the subtree: remove them from this inert root's managed nodes\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n      //   element, make that node a managed node.\n      this._observer = new MutationObserver(this._onMutation.bind(this));\n      this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n     * stored in this object and updates the state of all of the managed nodes.\n     */\n\n\n    _createClass(InertRoot, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._observer.disconnect();\n\n        if (this._rootElement) {\n          if (this._savedAriaHidden !== null) {\n            this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n          } else {\n            this._rootElement.removeAttribute('aria-hidden');\n          }\n        }\n\n        this._managedNodes.forEach(function (inertNode) {\n          this._unmanageNode(inertNode.node);\n        }, this);\n\n        // Note we cast the nulls to the ANY type here because:\n        // 1) We want the class properties to be declared as non-null, or else we\n        //    need even more casts throughout this code. All bets are off if an\n        //    instance has been destroyed and a method is called.\n        // 2) We don't want to cast \"this\", because we want type-aware optimizations\n        //    to know which properties we're setting.\n        this._observer = /** @type {?} */null;\n        this._rootElement = /** @type {?} */null;\n        this._managedNodes = /** @type {?} */null;\n        this._inertManager = /** @type {?} */null;\n      }\n\n      /**\n       * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n       */\n\n    }, {\n      key: '_makeSubtreeUnfocusable',\n\n\n      /**\n       * @param {!Node} startNode\n       */\n      value: function _makeSubtreeUnfocusable(startNode) {\n        var _this2 = this;\n\n        composedTreeWalk(startNode, function (node) {\n          return _this2._visitNode(node);\n        });\n\n        var activeElement = document.activeElement;\n\n        if (!document.body.contains(startNode)) {\n          // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n          var node = startNode;\n          /** @type {!ShadowRoot|undefined} */\n          var root = undefined;\n          while (node) {\n            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n              root = /** @type {!ShadowRoot} */node;\n              break;\n            }\n            node = node.parentNode;\n          }\n          if (root) {\n            activeElement = root.activeElement;\n          }\n        }\n        if (startNode.contains(activeElement)) {\n          activeElement.blur();\n          // In IE11, if an element is already focused, and then set to tabindex=-1\n          // calling blur() will not actually move the focus.\n          // To work around this we call focus() on the body instead.\n          if (activeElement === document.activeElement) {\n            document.body.focus();\n          }\n        }\n      }\n\n      /**\n       * @param {!Node} node\n       */\n\n    }, {\n      key: '_visitNode',\n      value: function _visitNode(node) {\n        if (node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n        var element = /** @type {!HTMLElement} */node;\n\n        // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n        // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n        if (element !== this._rootElement && element.hasAttribute('inert')) {\n          this._adoptInertRoot(element);\n        }\n\n        if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n          this._manageNode(element);\n        }\n      }\n\n      /**\n       * Register the given node with this InertRoot and with InertManager.\n       * @param {!Node} node\n       */\n\n    }, {\n      key: '_manageNode',\n      value: function _manageNode(node) {\n        var inertNode = this._inertManager.register(node, this);\n        this._managedNodes.add(inertNode);\n      }\n\n      /**\n       * Unregister the given node with this InertRoot and with InertManager.\n       * @param {!Node} node\n       */\n\n    }, {\n      key: '_unmanageNode',\n      value: function _unmanageNode(node) {\n        var inertNode = this._inertManager.deregister(node, this);\n        if (inertNode) {\n          this._managedNodes['delete'](inertNode);\n        }\n      }\n\n      /**\n       * Unregister the entire subtree starting at `startNode`.\n       * @param {!Node} startNode\n       */\n\n    }, {\n      key: '_unmanageSubtree',\n      value: function _unmanageSubtree(startNode) {\n        var _this3 = this;\n\n        composedTreeWalk(startNode, function (node) {\n          return _this3._unmanageNode(node);\n        });\n      }\n\n      /**\n       * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n       * @param {!HTMLElement} node\n       */\n\n    }, {\n      key: '_adoptInertRoot',\n      value: function _adoptInertRoot(node) {\n        var inertSubroot = this._inertManager.getInertRoot(node);\n\n        // During initialisation this inert root may not have been registered yet,\n        // so register it now if need be.\n        if (!inertSubroot) {\n          this._inertManager.setInert(node, true);\n          inertSubroot = this._inertManager.getInertRoot(node);\n        }\n\n        inertSubroot.managedNodes.forEach(function (savedInertNode) {\n          this._manageNode(savedInertNode.node);\n        }, this);\n      }\n\n      /**\n       * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n       * @param {!Array<!MutationRecord>} records\n       * @param {!MutationObserver} self\n       */\n\n    }, {\n      key: '_onMutation',\n      value: function _onMutation(records, self) {\n        records.forEach(function (record) {\n          var target = /** @type {!HTMLElement} */record.target;\n          if (record.type === 'childList') {\n            // Manage added nodes\n            slice.call(record.addedNodes).forEach(function (node) {\n              this._makeSubtreeUnfocusable(node);\n            }, this);\n\n            // Un-manage removed nodes\n            slice.call(record.removedNodes).forEach(function (node) {\n              this._unmanageSubtree(node);\n            }, this);\n          } else if (record.type === 'attributes') {\n            if (record.attributeName === 'tabindex') {\n              // Re-initialise inert node if tabindex changes\n              this._manageNode(target);\n            } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n              // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n              // already managed nodes from this inert subroot.\n              this._adoptInertRoot(target);\n              var inertSubroot = this._inertManager.getInertRoot(target);\n              this._managedNodes.forEach(function (managedNode) {\n                if (target.contains(managedNode.node)) {\n                  inertSubroot._manageNode(managedNode.node);\n                }\n              });\n            }\n          }\n        }, this);\n      }\n    }, {\n      key: 'managedNodes',\n      get: function get() {\n        return new Set(this._managedNodes);\n      }\n\n      /** @return {boolean} */\n\n    }, {\n      key: 'hasSavedAriaHidden',\n      get: function get() {\n        return this._savedAriaHidden !== null;\n      }\n\n      /** @param {?string} ariaHidden */\n\n    }, {\n      key: 'savedAriaHidden',\n      set: function set(ariaHidden) {\n        this._savedAriaHidden = ariaHidden;\n      }\n\n      /** @return {?string} */\n      ,\n      get: function get() {\n        return this._savedAriaHidden;\n      }\n    }]);\n\n    return InertRoot;\n  }();\n\n  /**\n   * `InertNode` initialises and manages a single inert node.\n   * A node is inert if it is a descendant of one or more inert root elements.\n   *\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n   * is intrinsically focusable or not.\n   *\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\n   */\n\n\n  var InertNode = function () {\n    /**\n     * @param {!Node} node A focusable element to be made inert.\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n     */\n    function InertNode(node, inertRoot) {\n      _classCallCheck(this, InertNode);\n\n      /** @type {!Node} */\n      this._node = node;\n\n      /** @type {boolean} */\n      this._overrodeFocusMethod = false;\n\n      /**\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\n       *    If and only if this set becomes empty, this node is no longer inert.\n       */\n      this._inertRoots = new Set([inertRoot]);\n\n      /** @type {?number} */\n      this._savedTabIndex = null;\n\n      /** @type {boolean} */\n      this._destroyed = false;\n\n      // Save any prior tabindex info and make this node untabbable\n      this.ensureUntabbable();\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.\n     * This makes the managed node focusable again and deletes all of the previously stored state.\n     */\n\n\n    _createClass(InertNode, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._throwIfDestroyed();\n\n        if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n          var element = /** @type {!HTMLElement} */this._node;\n          if (this._savedTabIndex !== null) {\n            element.setAttribute('tabindex', this._savedTabIndex);\n          } else {\n            element.removeAttribute('tabindex');\n          }\n\n          // Use `delete` to restore native focus method.\n          if (this._overrodeFocusMethod) {\n            delete element.focus;\n          }\n        }\n\n        // See note in InertRoot.destructor for why we cast these nulls to ANY.\n        this._node = /** @type {?} */null;\n        this._inertRoots = /** @type {?} */null;\n        this._destroyed = true;\n      }\n\n      /**\n       * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n       * If the object has been destroyed, any attempt to access it will cause an exception.\n       */\n\n    }, {\n      key: '_throwIfDestroyed',\n\n\n      /**\n       * Throw if user tries to access destroyed InertNode.\n       */\n      value: function _throwIfDestroyed() {\n        if (this.destroyed) {\n          throw new Error('Trying to access destroyed InertNode');\n        }\n      }\n\n      /** @return {boolean} */\n\n    }, {\n      key: 'ensureUntabbable',\n\n\n      /** Save the existing tabindex value and make the node untabbable and unfocusable */\n      value: function ensureUntabbable() {\n        if (this.node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n        var element = /** @type {!HTMLElement} */this.node;\n        if (matches.call(element, _focusableElementsString)) {\n          if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\n            return;\n          }\n\n          if (element.hasAttribute('tabindex')) {\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n          }\n          element.setAttribute('tabindex', '-1');\n          if (element.nodeType === Node.ELEMENT_NODE) {\n            element.focus = function () {};\n            this._overrodeFocusMethod = true;\n          }\n        } else if (element.hasAttribute('tabindex')) {\n          this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n          element.removeAttribute('tabindex');\n        }\n      }\n\n      /**\n       * Add another inert root to this inert node's set of managing inert roots.\n       * @param {!InertRoot} inertRoot\n       */\n\n    }, {\n      key: 'addInertRoot',\n      value: function addInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots.add(inertRoot);\n      }\n\n      /**\n       * Remove the given inert root from this inert node's set of managing inert roots.\n       * If the set of managing inert roots becomes empty, this node is no longer inert,\n       * so the object should be destroyed.\n       * @param {!InertRoot} inertRoot\n       */\n\n    }, {\n      key: 'removeInertRoot',\n      value: function removeInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots['delete'](inertRoot);\n        if (this._inertRoots.size === 0) {\n          this.destructor();\n        }\n      }\n    }, {\n      key: 'destroyed',\n      get: function get() {\n        return (/** @type {!InertNode} */this._destroyed\n        );\n      }\n    }, {\n      key: 'hasSavedTabIndex',\n      get: function get() {\n        return this._savedTabIndex !== null;\n      }\n\n      /** @return {!Node} */\n\n    }, {\n      key: 'node',\n      get: function get() {\n        this._throwIfDestroyed();\n        return this._node;\n      }\n\n      /** @param {?number} tabIndex */\n\n    }, {\n      key: 'savedTabIndex',\n      set: function set(tabIndex) {\n        this._throwIfDestroyed();\n        this._savedTabIndex = tabIndex;\n      }\n\n      /** @return {?number} */\n      ,\n      get: function get() {\n        this._throwIfDestroyed();\n        return this._savedTabIndex;\n      }\n    }]);\n\n    return InertNode;\n  }();\n\n  /**\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\n   *\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n   * is created for each such node, via the `_managedNodes` map.\n   */\n\n\n  var InertManager = function () {\n    /**\n     * @param {!Document} document\n     */\n    function InertManager(document) {\n      _classCallCheck(this, InertManager);\n\n      if (!document) {\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\n      }\n\n      /** @type {!Document} */\n      this._document = document;\n\n      /**\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertNode>}\n       */\n      this._managedNodes = new Map();\n\n      /**\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertRoot>}\n       */\n      this._inertRoots = new Map();\n\n      /**\n       * Observer for mutations on `document.body`.\n       * @type {!MutationObserver}\n       */\n      this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n      // Add inert style.\n      addInertStyle(document.head || document.body || document.documentElement);\n\n      // Wait for document to be loaded.\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n      } else {\n        this._onDocumentLoaded();\n      }\n    }\n\n    /**\n     * Set whether the given element should be an inert root or not.\n     * @param {!HTMLElement} root\n     * @param {boolean} inert\n     */\n\n\n    _createClass(InertManager, [{\n      key: 'setInert',\n      value: function setInert(root, inert) {\n        if (inert) {\n          if (this._inertRoots.has(root)) {\n            // element is already inert\n            return;\n          }\n\n          var inertRoot = new InertRoot(root, this);\n          root.setAttribute('inert', '');\n          this._inertRoots.set(root, inertRoot);\n          // If not contained in the document, it must be in a shadowRoot.\n          // Ensure inert styles are added there.\n          if (!this._document.body.contains(root)) {\n            var parent = root.parentNode;\n            while (parent) {\n              if (parent.nodeType === 11) {\n                addInertStyle(parent);\n              }\n              parent = parent.parentNode;\n            }\n          }\n        } else {\n          if (!this._inertRoots.has(root)) {\n            // element is already non-inert\n            return;\n          }\n\n          var _inertRoot = this._inertRoots.get(root);\n          _inertRoot.destructor();\n          this._inertRoots['delete'](root);\n          root.removeAttribute('inert');\n        }\n      }\n\n      /**\n       * Get the InertRoot object corresponding to the given inert root element, if any.\n       * @param {!Node} element\n       * @return {!InertRoot|undefined}\n       */\n\n    }, {\n      key: 'getInertRoot',\n      value: function getInertRoot(element) {\n        return this._inertRoots.get(element);\n      }\n\n      /**\n       * Register the given InertRoot as managing the given node.\n       * In the case where the node has a previously existing inert root, this inert root will\n       * be added to its set of inert roots.\n       * @param {!Node} node\n       * @param {!InertRoot} inertRoot\n       * @return {!InertNode} inertNode\n       */\n\n    }, {\n      key: 'register',\n      value: function register(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (inertNode !== undefined) {\n          // node was already in an inert subtree\n          inertNode.addInertRoot(inertRoot);\n        } else {\n          inertNode = new InertNode(node, inertRoot);\n        }\n\n        this._managedNodes.set(node, inertNode);\n\n        return inertNode;\n      }\n\n      /**\n       * De-register the given InertRoot as managing the given inert node.\n       * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n       * node from the InertManager's set of managed nodes if it is destroyed.\n       * If the node is not currently managed, this is essentially a no-op.\n       * @param {!Node} node\n       * @param {!InertRoot} inertRoot\n       * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n       */\n\n    }, {\n      key: 'deregister',\n      value: function deregister(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (!inertNode) {\n          return null;\n        }\n\n        inertNode.removeInertRoot(inertRoot);\n        if (inertNode.destroyed) {\n          this._managedNodes['delete'](node);\n        }\n\n        return inertNode;\n      }\n\n      /**\n       * Callback used when document has finished loading.\n       */\n\n    }, {\n      key: '_onDocumentLoaded',\n      value: function _onDocumentLoaded() {\n        // Find all inert roots in document and make them actually inert.\n        var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n        inertElements.forEach(function (inertElement) {\n          this.setInert(inertElement, true);\n        }, this);\n\n        // Comment this out to use programmatic API only.\n        this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });\n      }\n\n      /**\n       * Callback used when mutation observer detects attribute changes.\n       * @param {!Array<!MutationRecord>} records\n       * @param {!MutationObserver} self\n       */\n\n    }, {\n      key: '_watchForInert',\n      value: function _watchForInert(records, self) {\n        var _this = this;\n        records.forEach(function (record) {\n          switch (record.type) {\n            case 'childList':\n              slice.call(record.addedNodes).forEach(function (node) {\n                if (node.nodeType !== Node.ELEMENT_NODE) {\n                  return;\n                }\n                var inertElements = slice.call(node.querySelectorAll('[inert]'));\n                if (matches.call(node, '[inert]')) {\n                  inertElements.unshift(node);\n                }\n                inertElements.forEach(function (inertElement) {\n                  this.setInert(inertElement, true);\n                }, _this);\n              }, _this);\n              break;\n            case 'attributes':\n              if (record.attributeName !== 'inert') {\n                return;\n              }\n              var target = /** @type {!HTMLElement} */record.target;\n              var inert = target.hasAttribute('inert');\n              _this.setInert(target, inert);\n              break;\n          }\n        }, this);\n      }\n    }]);\n\n    return InertManager;\n  }();\n\n  /**\n   * Recursively walk the composed tree from |node|.\n   * @param {!Node} node\n   * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,\n   *     before descending into child nodes.\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n   */\n\n\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      var element = /** @type {!HTMLElement} */node;\n      if (callback) {\n        callback(element);\n      }\n\n      // Descend into node:\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\n      // up by the <content> or <shadow> elements. Descend straight into the\n      // ShadowRoot.\n      var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\n      if (shadowRoot) {\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\n        return;\n      }\n\n      // If it is a <content> element, descend into distributed elements - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'content') {\n        var content = /** @type {!HTMLContentElement} */element;\n        // Verifies if ShadowDom v0 is supported.\n        var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n        for (var i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n\n      // If it is a <slot> element, descend into assigned nodes - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'slot') {\n        var slot = /** @type {!HTMLSlotElement} */element;\n        // Verify if ShadowDom v1 is supported.\n        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];\n        for (var _i = 0; _i < _distributedNodes.length; _i++) {\n          composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n    }\n\n    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n    // element, nor a <shadow> element recurse normally.\n    var child = node.firstChild;\n    while (child != null) {\n      composedTreeWalk(child, callback, shadowRootAncestor);\n      child = child.nextSibling;\n    }\n  }\n\n  /**\n   * Adds a style element to the node containing the inert specific styles\n   * @param {!Node} node\n   */\n  function addInertStyle(node) {\n    if (node.querySelector('style#inert-style, link#inert-style')) {\n      return;\n    }\n    var style = document.createElement('style');\n    style.setAttribute('id', 'inert-style');\n    style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n    node.appendChild(style);\n  }\n\n  if (!HTMLElement.prototype.hasOwnProperty('inert')) {\n    /** @type {!InertManager} */\n    var inertManager = new InertManager(document);\n\n    Object.defineProperty(HTMLElement.prototype, 'inert', {\n      enumerable: true,\n      /** @this {!HTMLElement} */\n      get: function get() {\n        return this.hasAttribute('inert');\n      },\n      /** @this {!HTMLElement} */\n      set: function set(inert) {\n        inertManager.setInert(this, inert);\n      }\n    });\n  }\n})();\n","/**\n * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2022 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nfunction isArray(value) {\n  return !Array.isArray\n    ? getTag(value) === '[object Array]'\n    : Array.isArray(value)\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value\n  }\n  let result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result\n}\n\nfunction toString(value) {\n  return value == null ? '' : baseToString(value)\n}\n\nfunction isString(value) {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number'\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n  return (\n    value === true ||\n    value === false ||\n    (isObjectLike(value) && getTag(value) == '[object Boolean]')\n  )\n}\n\nfunction isObject(value) {\n  return typeof value === 'object'\n}\n\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n  return isObject(value) && value !== null\n}\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null\n}\n\nfunction isBlank(value) {\n  return !value.trim().length\n}\n\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n  return value == null\n    ? value === undefined\n      ? '[object Undefined]'\n      : '[object Null]'\n    : Object.prototype.toString.call(value)\n}\n\nconst EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\n\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\n\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>\n  `Invalid value for key ${key}`;\n\nconst PATTERN_LENGTH_TOO_LARGE = (max) =>\n  `Pattern length exceeds max of ${max}.`;\n\nconst MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;\n\nconst INVALID_KEY_WEIGHT_VALUE = (key) =>\n  `Property 'weight' in key '${key}' must be a positive integer`;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nclass KeyStore {\n  constructor(keys) {\n    this._keys = [];\n    this._keyMap = {};\n\n    let totalWeight = 0;\n\n    keys.forEach((key) => {\n      let obj = createKey(key);\n\n      totalWeight += obj.weight;\n\n      this._keys.push(obj);\n      this._keyMap[obj.id] = obj;\n\n      totalWeight += obj.weight;\n    });\n\n    // Normalize weights so that their sum is equal to 1\n    this._keys.forEach((key) => {\n      key.weight /= totalWeight;\n    });\n  }\n  get(keyId) {\n    return this._keyMap[keyId]\n  }\n  keys() {\n    return this._keys\n  }\n  toJSON() {\n    return JSON.stringify(this._keys)\n  }\n}\n\nfunction createKey(key) {\n  let path = null;\n  let id = null;\n  let src = null;\n  let weight = 1;\n  let getFn = null;\n\n  if (isString(key) || isArray(key)) {\n    src = key;\n    path = createKeyPath(key);\n    id = createKeyId(key);\n  } else {\n    if (!hasOwn.call(key, 'name')) {\n      throw new Error(MISSING_KEY_PROPERTY('name'))\n    }\n\n    const name = key.name;\n    src = name;\n\n    if (hasOwn.call(key, 'weight')) {\n      weight = key.weight;\n\n      if (weight <= 0) {\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))\n      }\n    }\n\n    path = createKeyPath(name);\n    id = createKeyId(name);\n    getFn = key.getFn;\n  }\n\n  return { path, id, weight, src, getFn }\n}\n\nfunction createKeyPath(key) {\n  return isArray(key) ? key : key.split('.')\n}\n\nfunction createKeyId(key) {\n  return isArray(key) ? key.join('.') : key\n}\n\nfunction get(obj, path) {\n  let list = [];\n  let arr = false;\n\n  const deepGet = (obj, path, index) => {\n    if (!isDefined(obj)) {\n      return\n    }\n    if (!path[index]) {\n      // If there's no path left, we've arrived at the object we care about.\n      list.push(obj);\n    } else {\n      let key = path[index];\n\n      const value = obj[key];\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      // If we're at the last value in the path, and if it's a string/number/bool,\n      // add it to the list\n      if (\n        index === path.length - 1 &&\n        (isString(value) || isNumber(value) || isBoolean(value))\n      ) {\n        list.push(toString(value));\n      } else if (isArray(value)) {\n        arr = true;\n        // Search each item in the array.\n        for (let i = 0, len = value.length; i < len; i += 1) {\n          deepGet(value[i], path, index + 1);\n        }\n      } else if (path.length) {\n        // An object. Recurse further.\n        deepGet(value, path, index + 1);\n      }\n    }\n  };\n\n  // Backwards compatibility (since path used to be a string)\n  deepGet(obj, isString(path) ? path.split('.') : path, 0);\n\n  return arr ? list : list[0]\n}\n\nconst MatchOptions = {\n  // Whether the matches should be included in the result set. When `true`, each record in the result\n  // set will include the indices of the matched characters.\n  // These can consequently be used for highlighting purposes.\n  includeMatches: false,\n  // When `true`, the matching function will continue to the end of a search pattern even if\n  // a perfect match has already been located in the string.\n  findAllMatches: false,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1\n};\n\nconst BasicOptions = {\n  // When `true`, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function: sort by ascending score, ascending index\n  sortFn: (a, b) =>\n    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1\n};\n\nconst FuzzyOptions = {\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100\n};\n\nconst AdvancedOptions = {\n  // When `true`, it enables the use of unix-like search commands\n  useExtendedSearch: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get,\n  // When `true`, search will ignore `location` and `distance`, so it won't matter\n  // where in the string the pattern appears.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n  ignoreLocation: false,\n  // When `true`, the calculation for the relevance score (used for sorting) will\n  // ignore the field-length norm.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n  ignoreFieldNorm: false,\n  // The weight to determine how much field length norm effects scoring.\n  fieldNormWeight: 1\n};\n\nvar Config = {\n  ...BasicOptions,\n  ...MatchOptions,\n  ...FuzzyOptions,\n  ...AdvancedOptions\n};\n\nconst SPACE = /[^ ]+/g;\n\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(weight = 1, mantissa = 3) {\n  const cache = new Map();\n  const m = Math.pow(10, mantissa);\n\n  return {\n    get(value) {\n      const numTokens = value.match(SPACE).length;\n\n      if (cache.has(numTokens)) {\n        return cache.get(numTokens)\n      }\n\n      // Default function is 1/sqrt(x), weight makes that variable\n      const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n\n      // In place of `toFixed(mantissa)`, for faster computation\n      const n = parseFloat(Math.round(norm * m) / m);\n\n      cache.set(numTokens, n);\n\n      return n\n    },\n    clear() {\n      cache.clear();\n    }\n  }\n}\n\nclass FuseIndex {\n  constructor({\n    getFn = Config.getFn,\n    fieldNormWeight = Config.fieldNormWeight\n  } = {}) {\n    this.norm = norm(fieldNormWeight, 3);\n    this.getFn = getFn;\n    this.isCreated = false;\n\n    this.setIndexRecords();\n  }\n  setSources(docs = []) {\n    this.docs = docs;\n  }\n  setIndexRecords(records = []) {\n    this.records = records;\n  }\n  setKeys(keys = []) {\n    this.keys = keys;\n    this._keysMap = {};\n    keys.forEach((key, idx) => {\n      this._keysMap[key.id] = idx;\n    });\n  }\n  create() {\n    if (this.isCreated || !this.docs.length) {\n      return\n    }\n\n    this.isCreated = true;\n\n    // List is Array<String>\n    if (isString(this.docs[0])) {\n      this.docs.forEach((doc, docIndex) => {\n        this._addString(doc, docIndex);\n      });\n    } else {\n      // List is Array<Object>\n      this.docs.forEach((doc, docIndex) => {\n        this._addObject(doc, docIndex);\n      });\n    }\n\n    this.norm.clear();\n  }\n  // Adds a doc to the end of the index\n  add(doc) {\n    const idx = this.size();\n\n    if (isString(doc)) {\n      this._addString(doc, idx);\n    } else {\n      this._addObject(doc, idx);\n    }\n  }\n  // Removes the doc at the specified index of the index\n  removeAt(idx) {\n    this.records.splice(idx, 1);\n\n    // Change ref index of every subsquent doc\n    for (let i = idx, len = this.size(); i < len; i += 1) {\n      this.records[i].i -= 1;\n    }\n  }\n  getValueForItemAtKeyId(item, keyId) {\n    return item[this._keysMap[keyId]]\n  }\n  size() {\n    return this.records.length\n  }\n  _addString(doc, docIndex) {\n    if (!isDefined(doc) || isBlank(doc)) {\n      return\n    }\n\n    let record = {\n      v: doc,\n      i: docIndex,\n      n: this.norm.get(doc)\n    };\n\n    this.records.push(record);\n  }\n  _addObject(doc, docIndex) {\n    let record = { i: docIndex, $: {} };\n\n    // Iterate over every key (i.e, path), and fetch the value at that key\n    this.keys.forEach((key, keyIndex) => {\n      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      if (isArray(value)) {\n        let subRecords = [];\n        const stack = [{ nestedArrIndex: -1, value }];\n\n        while (stack.length) {\n          const { nestedArrIndex, value } = stack.pop();\n\n          if (!isDefined(value)) {\n            continue\n          }\n\n          if (isString(value) && !isBlank(value)) {\n            let subRecord = {\n              v: value,\n              i: nestedArrIndex,\n              n: this.norm.get(value)\n            };\n\n            subRecords.push(subRecord);\n          } else if (isArray(value)) {\n            value.forEach((item, k) => {\n              stack.push({\n                nestedArrIndex: k,\n                value: item\n              });\n            });\n          } else ;\n        }\n        record.$[keyIndex] = subRecords;\n      } else if (isString(value) && !isBlank(value)) {\n        let subRecord = {\n          v: value,\n          n: this.norm.get(value)\n        };\n\n        record.$[keyIndex] = subRecord;\n      }\n    });\n\n    this.records.push(record);\n  }\n  toJSON() {\n    return {\n      keys: this.keys,\n      records: this.records\n    }\n  }\n}\n\nfunction createIndex(\n  keys,\n  docs,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys.map(createKey));\n  myIndex.setSources(docs);\n  myIndex.create();\n  return myIndex\n}\n\nfunction parseIndex(\n  data,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const { keys, records } = data;\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys);\n  myIndex.setIndexRecords(records);\n  return myIndex\n}\n\nfunction computeScore$1(\n  pattern,\n  {\n    errors = 0,\n    currentLocation = 0,\n    expectedLocation = 0,\n    distance = Config.distance,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  const accuracy = errors / pattern.length;\n\n  if (ignoreLocation) {\n    return accuracy\n  }\n\n  const proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy\n  }\n\n  return accuracy + proximity / distance\n}\n\nfunction convertMaskToIndices(\n  matchmask = [],\n  minMatchCharLength = Config.minMatchCharLength\n) {\n  let indices = [];\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        indices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    indices.push([start, i - 1]);\n  }\n\n  return indices\n}\n\n// Machine word size\nconst MAX_BITS = 32;\n\nfunction search(\n  text,\n  pattern,\n  patternAlphabet,\n  {\n    location = Config.location,\n    distance = Config.distance,\n    threshold = Config.threshold,\n    findAllMatches = Config.findAllMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    includeMatches = Config.includeMatches,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  if (pattern.length > MAX_BITS) {\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))\n  }\n\n  const patternLen = pattern.length;\n  // Set starting location at beginning text and initialize the alphabet.\n  const textLen = text.length;\n  // Handle the case when location > text.length\n  const expectedLocation = Math.max(0, Math.min(location, textLen));\n  // Highest score beyond which we give up.\n  let currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  let bestLocation = expectedLocation;\n\n  // Performance: only computer matches when the minMatchCharLength > 1\n  // OR if `includeMatches` is true.\n  const computeMatches = minMatchCharLength > 1 || includeMatches;\n  // A mask of the matches, used for building the indices\n  const matchMask = computeMatches ? Array(textLen) : [];\n\n  let index;\n\n  // Get all exact matches, here for speed up\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n    let score = computeScore$1(pattern, {\n      currentLocation: index,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index + patternLen;\n\n    if (computeMatches) {\n      let i = 0;\n      while (i < patternLen) {\n        matchMask[index + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  let lastBitArr = [];\n  let finalScore = 1;\n  let binMax = patternLen + textLen;\n\n  const mask = 1 << (patternLen - 1);\n\n  for (let i = 0; i < patternLen; i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    let binMin = 0;\n    let binMid = binMax;\n\n    while (binMin < binMid) {\n      const score = computeScore$1(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance,\n        ignoreLocation\n      });\n\n      if (score <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    let start = Math.max(1, expectedLocation - binMid + 1);\n    let finish = findAllMatches\n      ? textLen\n      : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    let bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << i) - 1;\n\n    for (let j = finish; j >= start; j -= 1) {\n      let currentLocation = j - 1;\n      let charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (computeMatches) {\n        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n        matchMask[currentLocation] = +!!charMatch;\n      }\n\n      // First pass: exact match\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (i) {\n        bitArr[j] |=\n          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = computeScore$1(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance,\n          ignoreLocation\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    const score = computeScore$1(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    if (score > currentThreshold) {\n      break\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  const result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: Math.max(0.001, finalScore)\n  };\n\n  if (computeMatches) {\n    const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n    if (!indices.length) {\n      result.isMatch = false;\n    } else if (includeMatches) {\n      result.indices = indices;\n    }\n  }\n\n  return result\n}\n\nfunction createPatternAlphabet(pattern) {\n  let mask = {};\n\n  for (let i = 0, len = pattern.length; i < len; i += 1) {\n    const char = pattern.charAt(i);\n    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));\n  }\n\n  return mask\n}\n\nclass BitapSearch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    this.options = {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    this.chunks = [];\n\n    if (!this.pattern.length) {\n      return\n    }\n\n    const addChunk = (pattern, startIndex) => {\n      this.chunks.push({\n        pattern,\n        alphabet: createPatternAlphabet(pattern),\n        startIndex\n      });\n    };\n\n    const len = this.pattern.length;\n\n    if (len > MAX_BITS) {\n      let i = 0;\n      const remainder = len % MAX_BITS;\n      const end = len - remainder;\n\n      while (i < end) {\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\n        i += MAX_BITS;\n      }\n\n      if (remainder) {\n        const startIndex = len - MAX_BITS;\n        addChunk(this.pattern.substr(startIndex), startIndex);\n      }\n    } else {\n      addChunk(this.pattern, 0);\n    }\n  }\n\n  searchIn(text) {\n    const { isCaseSensitive, includeMatches } = this.options;\n\n    if (!isCaseSensitive) {\n      text = text.toLowerCase();\n    }\n\n    // Exact match\n    if (this.pattern === text) {\n      let result = {\n        isMatch: true,\n        score: 0\n      };\n\n      if (includeMatches) {\n        result.indices = [[0, text.length - 1]];\n      }\n\n      return result\n    }\n\n    // Otherwise, use Bitap algorithm\n    const {\n      location,\n      distance,\n      threshold,\n      findAllMatches,\n      minMatchCharLength,\n      ignoreLocation\n    } = this.options;\n\n    let allIndices = [];\n    let totalScore = 0;\n    let hasMatches = false;\n\n    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {\n      const { isMatch, score, indices } = search(text, pattern, alphabet, {\n        location: location + startIndex,\n        distance,\n        threshold,\n        findAllMatches,\n        minMatchCharLength,\n        includeMatches,\n        ignoreLocation\n      });\n\n      if (isMatch) {\n        hasMatches = true;\n      }\n\n      totalScore += score;\n\n      if (isMatch && indices) {\n        allIndices = [...allIndices, ...indices];\n      }\n    });\n\n    let result = {\n      isMatch: hasMatches,\n      score: hasMatches ? totalScore / this.chunks.length : 1\n    };\n\n    if (hasMatches && includeMatches) {\n      result.indices = allIndices;\n    }\n\n    return result\n  }\n}\n\nclass BaseMatch {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n  static isMultiMatch(pattern) {\n    return getMatch(pattern, this.multiRegex)\n  }\n  static isSingleMatch(pattern) {\n    return getMatch(pattern, this.singleRegex)\n  }\n  search(/*text*/) {}\n}\n\nfunction getMatch(pattern, exp) {\n  const matches = pattern.match(exp);\n  return matches ? matches[1] : null\n}\n\n// Token: 'file\n\nclass ExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'exact'\n  }\n  static get multiRegex() {\n    return /^=\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^=(.*)$/\n  }\n  search(text) {\n    const isMatch = text === this.pattern;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !fire\n\nclass InverseExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!(.*)$/\n  }\n  search(text) {\n    const index = text.indexOf(this.pattern);\n    const isMatch = index === -1;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: ^file\n\nclass PrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'prefix-exact'\n  }\n  static get multiRegex() {\n    return /^\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !^fire\n\nclass InversePrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-prefix-exact'\n  }\n  static get multiRegex() {\n    return /^!\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = !text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: .file$\n\nclass SuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'suffix-exact'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = text.endsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [text.length - this.pattern.length, text.length - 1]\n    }\n  }\n}\n\n// Token: !.file$\n\nclass InverseSuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-suffix-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^!(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = !text.endsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\nclass FuzzyMatch extends BaseMatch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    super(pattern);\n    this._bitapSearch = new BitapSearch(pattern, {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    });\n  }\n  static get type() {\n    return 'fuzzy'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^(.*)$/\n  }\n  search(text) {\n    return this._bitapSearch.searchIn(text)\n  }\n}\n\n// Token: 'file\n\nclass IncludeMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'include'\n  }\n  static get multiRegex() {\n    return /^'\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^'(.*)$/\n  }\n  search(text) {\n    let location = 0;\n    let index;\n\n    const indices = [];\n    const patternLen = this.pattern.length;\n\n    // Get all exact matches\n    while ((index = text.indexOf(this.pattern, location)) > -1) {\n      location = index + patternLen;\n      indices.push([index, location - 1]);\n    }\n\n    const isMatch = !!indices.length;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices\n    }\n  }\n}\n\n// Order is important. DO NOT CHANGE.\nconst searchers = [\n  ExactMatch,\n  IncludeMatch,\n  PrefixExactMatch,\n  InversePrefixExactMatch,\n  InverseSuffixExactMatch,\n  SuffixExactMatch,\n  InverseExactMatch,\n  FuzzyMatch\n];\n\nconst searchersLen = searchers.length;\n\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = '|';\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n  return pattern.split(OR_TOKEN).map((item) => {\n    let query = item\n      .trim()\n      .split(SPACE_RE)\n      .filter((item) => item && !!item.trim());\n\n    let results = [];\n    for (let i = 0, len = query.length; i < len; i += 1) {\n      const queryItem = query[i];\n\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n      let found = false;\n      let idx = -1;\n      while (!found && ++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isMultiMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n\n      if (found) {\n        continue\n      }\n\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\n      idx = -1;\n      while (++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isSingleMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          break\n        }\n      }\n    }\n\n    return results\n  })\n}\n\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\n\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */\nclass ExtendedSearch {\n  constructor(\n    pattern,\n    {\n      isCaseSensitive = Config.isCaseSensitive,\n      includeMatches = Config.includeMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      ignoreLocation = Config.ignoreLocation,\n      findAllMatches = Config.findAllMatches,\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance\n    } = {}\n  ) {\n    this.query = null;\n    this.options = {\n      isCaseSensitive,\n      includeMatches,\n      minMatchCharLength,\n      findAllMatches,\n      ignoreLocation,\n      location,\n      threshold,\n      distance\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.query = parseQuery(this.pattern, this.options);\n  }\n\n  static condition(_, options) {\n    return options.useExtendedSearch\n  }\n\n  searchIn(text) {\n    const query = this.query;\n\n    if (!query) {\n      return {\n        isMatch: false,\n        score: 1\n      }\n    }\n\n    const { includeMatches, isCaseSensitive } = this.options;\n\n    text = isCaseSensitive ? text : text.toLowerCase();\n\n    let numMatches = 0;\n    let allIndices = [];\n    let totalScore = 0;\n\n    // ORs\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\n      const searchers = query[i];\n\n      // Reset indices\n      allIndices.length = 0;\n      numMatches = 0;\n\n      // ANDs\n      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {\n        const searcher = searchers[j];\n        const { isMatch, indices, score } = searcher.search(text);\n\n        if (isMatch) {\n          numMatches += 1;\n          totalScore += score;\n          if (includeMatches) {\n            const type = searcher.constructor.type;\n            if (MultiMatchSet.has(type)) {\n              allIndices = [...allIndices, ...indices];\n            } else {\n              allIndices.push(indices);\n            }\n          }\n        } else {\n          totalScore = 0;\n          numMatches = 0;\n          allIndices.length = 0;\n          break\n        }\n      }\n\n      // OR condition, so if TRUE, return\n      if (numMatches) {\n        let result = {\n          isMatch: true,\n          score: totalScore / numMatches\n        };\n\n        if (includeMatches) {\n          result.indices = allIndices;\n        }\n\n        return result\n      }\n    }\n\n    // Nothing was matched\n    return {\n      isMatch: false,\n      score: 1\n    }\n  }\n}\n\nconst registeredSearchers = [];\n\nfunction register(...args) {\n  registeredSearchers.push(...args);\n}\n\nfunction createSearcher(pattern, options) {\n  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {\n    let searcherClass = registeredSearchers[i];\n    if (searcherClass.condition(pattern, options)) {\n      return new searcherClass(pattern, options)\n    }\n  }\n\n  return new BitapSearch(pattern, options)\n}\n\nconst LogicalOperator = {\n  AND: '$and',\n  OR: '$or'\n};\n\nconst KeyType = {\n  PATH: '$path',\n  PATTERN: '$val'\n};\n\nconst isExpression = (query) =>\n  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n\nconst isPath = (query) => !!query[KeyType.PATH];\n\nconst isLeaf = (query) =>\n  !isArray(query) && isObject(query) && !isExpression(query);\n\nconst convertToExplicit = (query) => ({\n  [LogicalOperator.AND]: Object.keys(query).map((key) => ({\n    [key]: query[key]\n  }))\n});\n\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n  const next = (query) => {\n    let keys = Object.keys(query);\n\n    const isQueryPath = isPath(query);\n\n    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n      return next(convertToExplicit(query))\n    }\n\n    if (isLeaf(query)) {\n      const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n\n      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n\n      if (!isString(pattern)) {\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))\n      }\n\n      const obj = {\n        keyId: createKeyId(key),\n        pattern\n      };\n\n      if (auto) {\n        obj.searcher = createSearcher(pattern, options);\n      }\n\n      return obj\n    }\n\n    let node = {\n      children: [],\n      operator: keys[0]\n    };\n\n    keys.forEach((key) => {\n      const value = query[key];\n\n      if (isArray(value)) {\n        value.forEach((item) => {\n          node.children.push(next(item));\n        });\n      }\n    });\n\n    return node\n  };\n\n  if (!isExpression(query)) {\n    query = convertToExplicit(query);\n  }\n\n  return next(query)\n}\n\n// Practical scoring function\nfunction computeScore(\n  results,\n  { ignoreFieldNorm = Config.ignoreFieldNorm }\n) {\n  results.forEach((result) => {\n    let totalScore = 1;\n\n    result.matches.forEach(({ key, norm, score }) => {\n      const weight = key ? key.weight : null;\n\n      totalScore *= Math.pow(\n        score === 0 && weight ? Number.EPSILON : score,\n        (weight || 1) * (ignoreFieldNorm ? 1 : norm)\n      );\n    });\n\n    result.score = totalScore;\n  });\n}\n\nfunction transformMatches(result, data) {\n  const matches = result.matches;\n  data.matches = [];\n\n  if (!isDefined(matches)) {\n    return\n  }\n\n  matches.forEach((match) => {\n    if (!isDefined(match.indices) || !match.indices.length) {\n      return\n    }\n\n    const { indices, value } = match;\n\n    let obj = {\n      indices,\n      value\n    };\n\n    if (match.key) {\n      obj.key = match.key.src;\n    }\n\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n\n    data.matches.push(obj);\n  });\n}\n\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\n\nfunction format(\n  results,\n  docs,\n  {\n    includeMatches = Config.includeMatches,\n    includeScore = Config.includeScore\n  } = {}\n) {\n  const transformers = [];\n\n  if (includeMatches) transformers.push(transformMatches);\n  if (includeScore) transformers.push(transformScore);\n\n  return results.map((result) => {\n    const { idx } = result;\n\n    const data = {\n      item: docs[idx],\n      refIndex: idx\n    };\n\n    if (transformers.length) {\n      transformers.forEach((transformer) => {\n        transformer(result, data);\n      });\n    }\n\n    return data\n  })\n}\n\nclass Fuse {\n  constructor(docs, options = {}, index) {\n    this.options = { ...Config, ...options };\n\n    if (\n      this.options.useExtendedSearch &&\n      !true\n    ) {\n      throw new Error(EXTENDED_SEARCH_UNAVAILABLE)\n    }\n\n    this._keyStore = new KeyStore(this.options.keys);\n\n    this.setCollection(docs, index);\n  }\n\n  setCollection(docs, index) {\n    this._docs = docs;\n\n    if (index && !(index instanceof FuseIndex)) {\n      throw new Error(INCORRECT_INDEX_TYPE)\n    }\n\n    this._myIndex =\n      index ||\n      createIndex(this.options.keys, this._docs, {\n        getFn: this.options.getFn,\n        fieldNormWeight: this.options.fieldNormWeight\n      });\n  }\n\n  add(doc) {\n    if (!isDefined(doc)) {\n      return\n    }\n\n    this._docs.push(doc);\n    this._myIndex.add(doc);\n  }\n\n  remove(predicate = (/* doc, idx */) => false) {\n    const results = [];\n\n    for (let i = 0, len = this._docs.length; i < len; i += 1) {\n      const doc = this._docs[i];\n      if (predicate(doc, i)) {\n        this.removeAt(i);\n        i -= 1;\n        len -= 1;\n\n        results.push(doc);\n      }\n    }\n\n    return results\n  }\n\n  removeAt(idx) {\n    this._docs.splice(idx, 1);\n    this._myIndex.removeAt(idx);\n  }\n\n  getIndex() {\n    return this._myIndex\n  }\n\n  search(query, { limit = -1 } = {}) {\n    const {\n      includeMatches,\n      includeScore,\n      shouldSort,\n      sortFn,\n      ignoreFieldNorm\n    } = this.options;\n\n    let results = isString(query)\n      ? isString(this._docs[0])\n        ? this._searchStringList(query)\n        : this._searchObjectList(query)\n      : this._searchLogical(query);\n\n    computeScore(results, { ignoreFieldNorm });\n\n    if (shouldSort) {\n      results.sort(sortFn);\n    }\n\n    if (isNumber(limit) && limit > -1) {\n      results = results.slice(0, limit);\n    }\n\n    return format(results, this._docs, {\n      includeMatches,\n      includeScore\n    })\n  }\n\n  _searchStringList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { records } = this._myIndex;\n    const results = [];\n\n    // Iterate over every string in the index\n    records.forEach(({ v: text, i: idx, n: norm }) => {\n      if (!isDefined(text)) {\n        return\n      }\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        results.push({\n          item: text,\n          idx,\n          matches: [{ score, value: text, norm, indices }]\n        });\n      }\n    });\n\n    return results\n  }\n\n  _searchLogical(query) {\n\n    const expression = parse(query, this.options);\n\n    const evaluate = (node, item, idx) => {\n      if (!node.children) {\n        const { keyId, searcher } = node;\n\n        const matches = this._findMatches({\n          key: this._keyStore.get(keyId),\n          value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n          searcher\n        });\n\n        if (matches && matches.length) {\n          return [\n            {\n              idx,\n              item,\n              matches\n            }\n          ]\n        }\n\n        return []\n      }\n\n      const res = [];\n      for (let i = 0, len = node.children.length; i < len; i += 1) {\n        const child = node.children[i];\n        const result = evaluate(child, item, idx);\n        if (result.length) {\n          res.push(...result);\n        } else if (node.operator === LogicalOperator.AND) {\n          return []\n        }\n      }\n      return res\n    };\n\n    const records = this._myIndex.records;\n    const resultMap = {};\n    const results = [];\n\n    records.forEach(({ $: item, i: idx }) => {\n      if (isDefined(item)) {\n        let expResults = evaluate(expression, item, idx);\n\n        if (expResults.length) {\n          // Dedupe when adding\n          if (!resultMap[idx]) {\n            resultMap[idx] = { idx, item, matches: [] };\n            results.push(resultMap[idx]);\n          }\n          expResults.forEach(({ matches }) => {\n            resultMap[idx].matches.push(...matches);\n          });\n        }\n      }\n    });\n\n    return results\n  }\n\n  _searchObjectList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { keys, records } = this._myIndex;\n    const results = [];\n\n    // List is Array<Object>\n    records.forEach(({ $: item, i: idx }) => {\n      if (!isDefined(item)) {\n        return\n      }\n\n      let matches = [];\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      keys.forEach((key, keyIndex) => {\n        matches.push(\n          ...this._findMatches({\n            key,\n            value: item[keyIndex],\n            searcher\n          })\n        );\n      });\n\n      if (matches.length) {\n        results.push({\n          idx,\n          item,\n          matches\n        });\n      }\n    });\n\n    return results\n  }\n  _findMatches({ key, value, searcher }) {\n    if (!isDefined(value)) {\n      return []\n    }\n\n    let matches = [];\n\n    if (isArray(value)) {\n      value.forEach(({ v: text, i: idx, n: norm }) => {\n        if (!isDefined(text)) {\n          return\n        }\n\n        const { isMatch, score, indices } = searcher.searchIn(text);\n\n        if (isMatch) {\n          matches.push({\n            score,\n            key,\n            value: text,\n            idx,\n            norm,\n            indices\n          });\n        }\n      });\n    } else {\n      const { v: text, n: norm } = value;\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        matches.push({ score, key, value: text, norm, indices });\n      }\n    }\n\n    return matches\n  }\n}\n\nFuse.version = '6.6.2';\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n\n{\n  Fuse.parseQuery = parse;\n}\n\n{\n  register(ExtendedSearch);\n}\n\nexport { Fuse as default };\n",".docs-search {\n  position: fixed;\n  z-index: 2;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity 0.2s linear, visibility 0s 0.2s linear;\n}\n\n.docs-search--active {\n  transition: opacity 0.2s linear;\n  opacity: 1;\n  visibility: visible;\n}\n\n.docs-search__backdrop {\n  appearance: none;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  cursor: pointer;\n  top: 0;\n  left: 0;\n  border: 0;\n  padding: 0;\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  background-color: var(--ld-col-neutral-900);\n  opacity: 0.8;\n  z-index: -1;\n}\n\n.docs-search__content {\n  min-width: 18rem;\n  max-width: 30rem;\n  width: calc(100% - var(--ld-sp-40));\n  height: 75vh;\n  pointer-events: none;\n}\n\n.docs-search__input {\n  width: 100%;\n  pointer-events: all;\n\n  &::before {\n    box-shadow: none !important;\n  }\n\n  &[aria-expanded='true'] {\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n\n  .docs-search__input-icon {\n    margin-left: var(--ld-sp-16);\n  }\n}\n\n.docs-search__input-icon {\n  width: var(--ld-sp-16);\n  height: var(--ld-sp-16);\n}\n\n.docs-search__results {\n  background-color: var(--ld-col-wht);\n  pointer-events: all;\n  list-style: none;\n  max-height: calc(100% - var(--ld-sp-40));\n  overflow: hidden auto;\n  border-bottom-left-radius: var(--ld-br-m);\n  border-bottom-right-radius: var(--ld-br-m);\n  transform: translateY(-1px); /* fixes render issue on safari */\n}\n\n.docs-search__results--expanded {\n  &::before {\n    content: '';\n    display: block;\n    height: var(--ld-sp-1);\n    background-color: var(--ld-col-neutral-100);\n    margin: 0 auto;\n    width: calc(100% - var(--ld-sp-32));\n  }\n}\n\n.docs-search__result {\n  font: var(--ld-typo-body-m);\n\n  a {\n    text-decoration: none;\n    color: var(--ld-col-neutral-900);\n    display: block;\n    padding: var(--ld-sp-16);\n    outline: none;\n\n    &:focus:focus-visible {\n      background-color: var(--ld-col-neutral-050);\n    }\n    @media (hover: hover) {\n      &:where(:hover) {\n        background-color: var(--ld-col-neutral-010);\n      }\n    }\n    &:active,\n    &:active:focus-visible {\n      background-color: var(--ld-col-neutral-050);\n    }\n  }\n}\n\n.docs-search__result-crumbs {\n  display: block;\n}\n\n.docs-search__result-crumb:not(:last-of-type) {\n  margin-right: var(--ld-sp-4);\n\n  &::after {\n    content: '';\n    background-image: url('dist/build/assets/chevron-components-dark.svg');\n    background-repeat: no-repeat;\n    width: 0.8rem;\n    height: 1.375rem;\n    margin-left: var(--ld-sp-12);\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n  }\n}\n","import 'wicg-inert'\nimport { Component, h, Listen, State, Host } from '@stencil/core'\nimport Fuse from 'fuse.js'\nimport eventBus from '../../utils/eventBus'\nimport { SearchEventType } from '../../utils/eventTypes'\n\ninterface SearchResult {\n  breadcrumbs: string[]\n  headings: ''\n  tags: string\n  title: string\n  url: string\n}\n\n/** @internal **/\n@Component({\n  tag: 'docs-search',\n  styleUrl: 'docs-search.css',\n  shadow: false,\n  assetsDirs: ['assets'],\n})\nexport class DocsSearch {\n  private searchInput!: HTMLLdInputElement\n  private searchResults!: HTMLOListElement\n  private fuse: Fuse<SearchResult>\n\n  @State() results: Fuse.FuseResult<SearchResult>[] = []\n  @State() isActive: boolean\n\n  @Listen('click', { capture: true })\n  handleClick(ev) {\n    if (ev.target.id === 'docs-search-backdrop') {\n      ev.preventDefault()\n      this.onSearchClose()\n    }\n  }\n\n  @Listen('keydown', {\n    passive: true,\n  })\n  handleEscapeDown(ev: KeyboardEvent) {\n    if (!this.isActive) {\n      return\n    }\n    if (ev.key === 'Escape') {\n      ev.stopImmediatePropagation()\n      this.onSearchClose()\n    }\n  }\n\n  @Listen('keydown', {\n    passive: false,\n  })\n  handleKeyDown(ev: KeyboardEvent) {\n    if (!this.isActive) {\n      return\n    }\n    switch (ev.key) {\n      case 'ArrowDown': {\n        ev.preventDefault()\n\n        if (\n          document.activeElement.closest('.docs-search__input') ===\n          this.searchInput\n        ) {\n          ;(\n            this.searchResults.querySelector(\n              '.docs-search__result > a'\n            ) as HTMLAnchorElement\n          )?.focus()\n          return\n        }\n\n        const nextSibling = document.activeElement.closest(\n          '.docs-search__result'\n        )?.nextElementSibling\n        if (nextSibling?.classList.contains('docs-search__result')) {\n          ;(nextSibling.querySelector('a') as HTMLAnchorElement).focus()\n        }\n        return\n      }\n\n      case 'ArrowUp': {\n        ev.preventDefault()\n\n        const focusedSearchResult = document.activeElement.closest(\n          '.docs-search__result'\n        )\n\n        if (focusedSearchResult) {\n          const prevSibling = focusedSearchResult.previousElementSibling\n          if (prevSibling?.classList.contains('docs-search__result')) {\n            ;(prevSibling.querySelector('a') as HTMLAnchorElement).focus()\n          } else {\n            this.searchInput.shadowRoot.querySelector('input').focus()\n            this.searchResults.scrollTo(0, 0)\n          }\n        }\n        return\n      }\n\n      case ' ': {\n        const focusedSearchResult = document.activeElement.closest(\n          '.docs-search__result'\n        )\n\n        if (focusedSearchResult) {\n          ev.preventDefault()\n          window.location.href = (\n            focusedSearchResult.querySelector('a') as HTMLAnchorElement\n          ).href\n        }\n        return\n      }\n    }\n  }\n\n  @Listen('submit')\n  handleSubmit(ev: Event) {\n    ev.preventDefault()\n  }\n\n  private handleChange() {\n    const searchResult = this.fuse.search(this.searchInput.value)\n    this.results = searchResult\n  }\n\n  componentWillLoad() {\n    this.fuse = new Fuse(window['__docsSearchIndex__'], {\n      keys: [\n        {\n          name: 'title',\n          weight: 0.4,\n        },\n        {\n          name: 'tags',\n          weight: 0.35,\n        },\n        {\n          name: 'headings',\n          weight: 0.25,\n        },\n      ],\n      distance: 10000,\n      threshold: 0.3,\n    })\n  }\n\n  componentDidLoad() {\n    eventBus.on(SearchEventType.open, this.onSearchOpen.bind(this))\n  }\n\n  private onSearchOpen() {\n    document.getElementById('docs-layout').setAttribute('inert', 'true')\n    this.isActive = true\n    this.searchInput.value = ''\n    setTimeout(() => {\n      this.searchInput.focusInner()\n    }, 200)\n  }\n\n  private onSearchClose() {\n    document.getElementById('docs-layout').removeAttribute('inert')\n    this.isActive = false\n    this.results = []\n    eventBus.emit(SearchEventType.close)\n  }\n\n  render() {\n    return (\n      <Host\n        inert={!this.isActive}\n        class={`docs-search${this.isActive ? ' docs-search--active' : ''}`}\n      >\n        <div class=\"docs-search__content\">\n          <form role=\"search\" autocomplete=\"off\">\n            <ld-input\n              size=\"lg\"\n              aria-expanded={this.results.length ? 'true' : 'false'}\n              aria-controls=\"docs-search-results-list\"\n              onInput={this.handleChange.bind(this)}\n              placeholder=\"Search in documentation...\"\n              class=\"docs-search__input\"\n              id=\"docs-search-input\"\n              ref={(el) => (this.searchInput = el as HTMLLdInputElement)}\n              type=\"search\"\n              spellcheck={false}\n            >\n              <svg\n                aria-hidden=\"true\"\n                slot=\"start\"\n                class=\"docs-search__input-icon\"\n                fill=\"none\"\n                viewBox=\"0 0 18 19\"\n              >\n                <ellipse\n                  cx=\"7.54523\"\n                  cy=\"7.74543\"\n                  stroke=\"#091734\"\n                  stroke-width=\"2\"\n                  rx=\"6.54523\"\n                  ry=\"6.54548\"\n                />\n                <path\n                  stroke=\"#091734\"\n                  stroke-linecap=\"round\"\n                  stroke-linejoin=\"round\"\n                  stroke-width=\"2\"\n                  d=\"M12.6367 12.8362l4.3635 4.3636\"\n                />\n              </svg>\n            </ld-input>\n          </form>\n          <ol\n            id=\"docs-search-results-list\"\n            class={`docs-search__results${\n              this.results.length ? ' docs-search__results--expanded' : ''\n            }`}\n            aria-label=\"Search results\"\n            ref={(el) => (this.searchResults = el as HTMLOListElement)}\n          >\n            {this.results.length\n              ? this.results.map((result) => {\n                  if (!result.item.breadcrumbs.length) return ''\n                  return (\n                    <li class=\"docs-search__result\" key={result.refIndex}>\n                      <a href={result.item.url}>\n                        <b>{result.item.title}</b>\n                        <span class=\"docs-search__result-crumbs\">\n                          {result.item.breadcrumbs.map((crumb) => (\n                            <span class=\"docs-search__result-crumb\">\n                              {crumb}\n                            </span>\n                          ))}\n                        </span>\n                      </a>\n                    </li>\n                  )\n                })\n              : ''}\n          </ol>\n        </div>\n        <button\n          id=\"docs-search-backdrop\"\n          class=\"docs-search__backdrop\"\n          aria-label=\"Close search\"\n        ></button>\n      </Host>\n    )\n  }\n}\n"],"mappings":"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"}