/* eslint-disable @typescript-eslint/no-var-requires */
const nodeFetch = require('node-fetch')
const { writeFile } = require('fs').promises

function pxToRem(px: string | number) {
  return parseInt(px + '') / 16 + 'rem'
}

function rgbToHex(r, g, b) {
  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)
}

function parseShadows(items) {
  const shadows = {}

  for (const item of items) {
    shadows[item.name.split(' ')[0].toLowerCase()] = item.effects
      .map((effect) => {
        const col = effect.color
        return `${pxToRem(effect.offset.x)} ${pxToRem(
          effect.offset.y
        )} ${pxToRem(effect.radius)} rgba(${Math.round(
          col.r * 255
        )}, ${Math.round(col.g * 255)}, ${Math.round(col.b * 255)}, ${
          Math.round(col.a * 100) / 100
        })`
      })
      .join(', ')
  }

  return shadows
}

function parseColors(items) {
  const colors = {}

  for (const item of items) {
    if (item.fills?.length) {
      const rgbColor = item.fills[0].color
      colors[item.name.split('_')[0].toLowerCase()] = rgbToHex(
        Math.round(rgbColor.r * 255),
        Math.round(rgbColor.g * 255),
        Math.round(rgbColor.b * 255)
      )
    }
  }

  return colors
}

function parseTypography(itemsDisplay, itemsBody) {
  const typography = {
    display: {},
    body: {},
  }

  for (const item of itemsDisplay) {
    typography.display[item.name.split(' ')[0].toLowerCase()] = {
      fontSize: pxToRem(item.style.fontSize),
      lineHeight: Math.round(item.style.lineHeightPercentFontSize) + '%',
      fontFamiliy: item.style.fontFamily === 'Lato' ? 'Lato' : 'MWeb',
    }
  }

  const fontNameMap = {
    'XS Paragraph': 'body-xs',
    'S Paragraph': 'body-s',
    'M Paragraph': 'body-m',
    'L Paragraph': 'body-l',
    'XL Paragraph': 'body-xl',
    'Caption Medium': 'cap-m',
    'Caption Large': 'cap-l',
    'Mobile Label': 'label-s',
    'Default Label': 'label-m',
  }

  for (const item of itemsBody) {
    typography.body[fontNameMap[item.name]] = {
      fontSize: pxToRem(item.style.fontSize),
      lineHeight: Math.round(item.style.lineHeightPercentFontSize) + '%',
      fontFamiliy: item.style.fontFamily === 'Lato' ? 'Lato' : 'MWeb',
    }
  }

  return typography
}

function parseSpacings(items) {
  const spacings = {}

  for (const item of items) {
    spacings[item.name.split('$spacing-')[1]] = pxToRem(
      item.absoluteBoundingBox.height
    )
  }

  return spacings
}

async function getTokensFromFigma(figmaId = '5UbVMMa68tkeSlrNWgZw93') {
  const result = await nodeFetch('https://api.figma.com/v1/files/' + figmaId, {
    method: 'GET',
    headers: {
      'X-Figma-Token': process.env.FIGMA_API_KEY,
    },
  })
  const figmaData = (await result.json()).document.children.filter((item) => {
    return item.name === 'Liquid Design Tokens'
  })[0].children

  const tokens = {
    shadows: parseShadows(
      figmaData.find((child) => child.name === 'Shadows').children
    ),
    spacings: parseSpacings(
      figmaData.find((child) => child.name === 'Spacings').children
    ),
    colors: parseColors(
      figmaData.find((child) => child.name === 'Accessible Colors').children
    ),
    typography: parseTypography(
      figmaData.find((child) => child.name === 'Headlines').children,
      figmaData.find((child) => child.name === 'Paragraphs').children
    ),
  }

  return tokens
}

function generateShadows(tokens) {
  return writeFile(
    './src/liquid/global/styles/shadows/shadows.css',
    '/* autogenerated */\n:root {\n' +
      Object.keys(tokens)
        .sort()
        .map((key) => `  --ld-shadow-${key}: ${tokens[key]};`)
        .join('\n') +
      '\n}\n',
    'utf8'
  )
}

function generateColors(tokens) {
  return writeFile(
    './src/liquid/global/styles/colors/colors.css',
    '/* autogenerated */\n:root {\n' +
      Object.keys(tokens)
        .sort()
        .map((key) => {
          const val = tokens[key]
          if (key.includes('/default')) {
            return (
              `  --ld-col-${key.split('/default')[0]}: ${val};\n` +
              `  --ld-col-${key.slice(0, -'x/default'.length)}-default: ${val};`
            )
          }
          return `  --ld-col-${key}: ${val};`
        })
        .join('\n') +
      '\n}\n',
    'utf8'
  )
}

function generateSpacings(tokens) {
  return writeFile(
    './src/liquid/global/styles/spacings/spacings.css',
    '/* autogenerated */\n:root {\n' +
      Object.keys(tokens)
        .sort((key) => parseInt(key))
        .map((key) => `  --ld-sp-${key}: ${tokens[key]};`)
        .join('\n') +
      '\n}\n',
    'utf8'
  )
}

function generateTypography(tokens) {
  return writeFile(
    './src/liquid/global/styles/typography/typography.css',
    '/* autogenerated */\n:root {\n' +
      "  --ld-font-body: 'Lato', Helvetica, Arial, sans-serif;\n" +
      "  --ld-font-display: 'MWeb', Helvetica, Arial, sans-serif;\n" +
      Object.keys(tokens.display)
        .sort()
        .map((key) => {
          const val = tokens.display[key]
          return `  --ld-typo-${key}: ${val.fontSize} / ${
            val.lineHeight
          } var(--ld-font-${val.fontFamiliy === 'Lato' ? 'body' : 'display'});`
        })
        .join('\n') +
      '\n' +
      Object.keys(tokens.body)
        .sort()
        .map((key) => {
          const val = tokens.body[key]
          return `  --ld-typo-${key}: ${val.fontSize} / ${val.lineHeight} var(--ld-font-body);`
        })
        .join('\n') +
      '\n}\n',
    'utf8'
  )
}

function generateCSSTokenFiles(tokenCollection) {
  return Promise.all([
    generateShadows(tokenCollection.shadows),
    generateColors(tokenCollection.colors),
    generateSpacings(tokenCollection.spacings),
    generateTypography(tokenCollection.typography),
  ])
}

// eslint-disable-next-line @typescript-eslint/no-extra-semi
;(async () => {
  try {
    const tokenCollection = await getTokensFromFigma()
    await generateCSSTokenFiles(tokenCollection)
  } catch (err) {
    console.error('error', err)
  }
})()
